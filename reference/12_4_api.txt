
// Helper function to get restaurant name from menu item
async function getRestaurantForMenuItem(menuItemId) {
  try {
    // Method 1: Get menu_id from menu_item, then get restaurant from menu.restaurant_id
    const { data: menuItem, error: itemError } = await supabase
      .from('menu_item')
      .select('menu_id')
      .eq('menu_item_id', menuItemId)
      .single();

    if (!itemError && menuItem?.menu_id) {
      // Get restaurant directly from menu table (menu has direct restaurant_id FK)
      const { data: menu, error: menuError } = await supabase
        .from('menu')
        .select(`
          restaurant_id,
          restaurant:restaurant_id (
            name,
            description,
            restaurant_id
          )
        `)
        .eq('menu_id', menuItem.menu_id)
        .single();

      if (!menuError && menu?.restaurant) {
        return menu.restaurant;
      }
    }

    // Method 2: Try location_menu -> location -> restaurant relationship
    if (menuItem?.menu_id) {
      const { data: locationMenus, error: locError } = await supabase
        .from('location_menu')
        .select(`
          location_id,
          location:location_id (
            restaurant_id,
            restaurant:restaurant_id (
              name,
              description,
              restaurant_id
            )
          )
        `)
        .eq('menu_id', menuItem.menu_id)
        .limit(1);

      if (!locError && locationMenus && locationMenus.length > 0 && locationMenus[0].location?.restaurant) {
        return locationMenus[0].location.restaurant;
      }
    }

    console.log('No restaurant found for menu_item_id:', menuItemId, 'after trying all methods');
    return null;
  } catch (error) {
    console.error('Error getting restaurant:', error);
    return null;
  }
}

// Helper function to get base price for menu item
async function getBasePrice(menuItemId) {
  try {
    // Try item_price table first
    const { data: priceData, error: priceError } = await supabase
      .from('item_price')
      .select('price_cents')
      .eq('menu_item_id', menuItemId)
      .eq('is_active', true)
      .order('updated_at', { ascending: false })
      .limit(1);

    if (!priceError && priceData && priceData.length > 0) {
      return (priceData[0].price_cents / 100).toFixed(2);
    }

    return null;
  } catch (error) {
    console.error('Error getting price:', error);
    return null;
  }
}

// Helper function to get nutrition for menu item
async function getNutritionForMenuItem(menuItemId) {
  try {
    const { data: nutritionData, error: nutError } = await supabase
      .from('menu_item_nutrition')
      .select(`
        nutrition:nutrition_id (*)
      `)
      .eq('menu_item_id', menuItemId)
      .limit(1);

    if (nutError || !nutritionData || nutritionData.length === 0) return null;
    return nutritionData[0].nutrition;
  } catch (error) {
    return null;
  }
}

// Helper function to calculate calories range
function getCaloriesRange(nutrition, customizations) {
  if (!nutrition) return null;
  
  const baseCalories = nutrition.calories || 0;
  // Simplified range calculation - would need actual customization nutrition in real implementation
  const minCalories = baseCalories;
  const maxCalories = baseCalories + (customizations?.length || 0) * 200;
  
  return `${minCalories}‚Äì${maxCalories}`;
}

// Helper function to get possible diets for menu item
async function getPossibleDiets(menuItemId) {
  try {
    const { data: diets, error: dietError } = await supabase
      .from('menu_item_diet')
      .select(`
        diet:diet_id (
          diet_name
        )
      `)
      .eq('menu_item_id', menuItemId);

    if (dietError || !diets) return [];
    return diets.map(d => d.diet?.diet_name).filter(Boolean);
  } catch (error) {
    return [];
  }
}

// Test endpoint
app.get('/', (req, res) => {
  res.json({ message: 'Menu Items API v3 - Enhanced Configuration Server Running' });
});

// 1. GET /menu-items/:id
// Get menu item with enhanced details
app.get('/api/menu-items/:id', async (req, res) => {
  try {
    const menuItemId = req.params.id;

    // Get base menu item
    const { data: menuItem, error: itemError } = await supabase
      .from('menu_item')
      .select('*')
      .eq('menu_item_id', menuItemId)
      .single();

    if (itemError) throw itemError;

    // Get restaurant name
    const restaurant = await getRestaurantForMenuItem(menuItemId);

    // Get base price
    const basePrice = await getBasePrice(menuItemId);

    // Get nutrition
    const nutrition = await getNutritionForMenuItem(menuItemId);

    // Get customization options
    const { data: customizations, error: custError } = await supabase
      .from('menu_item_customization')
      .select(`
        *,
        custom_option:option_id (
          option_id,
          name,
          option_type
        )
      `)
      .eq('menu_item_id', menuItemId)
      .order('display_order');

    // Get diets
    const diets = await getPossibleDiets(menuItemId);

    // Get images
    const { data: images, error: imgError } = await supabase
      .from('menu_item_image')
      .select(`
        *,
        image:image_id (
          image_url,
          type,
          is_generated
        )
      `)
      .eq('menu_item_id', menuItemId)
      .order('display_order');

    // Calculate calories range
    const caloriesRange = getCaloriesRange(nutrition, customizations);

    // Format custom options
    const customOptions = (customizations || []).map(c => ({
      option_id: c.custom_option?.option_id,
      name: c.custom_option?.name,
      is_required: c.is_required,
      type: c.custom_option?.option_type
    }));

    // Format images
    const formattedImages = (images || []).map(img => ({
      url: img.image?.image_url,
      type: img.image?.type || 'food',
      is_generated: img.image?.is_generated || false
    }));

    res.json({
      data: {
        menu_item_id: parseInt(menuItemId),
        display_name: menuItem.display_name,
        restaurant: restaurant?.name || 'Unknown Restaurant',
        base_price: basePrice ? parseFloat(basePrice) : null,
        calories_range: caloriesRange,
        diets_possible: diets,
        images: formattedImages,
        custom_options: customOptions
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// 2. GET /menu-items/:id/configure
// Configure a menu item with specific options
app.get('/api/menu-items/:id/configure', async (req, res) => {
  try {
    const menuItemId = req.params.id;
    const { options } = req.query; // Expected format: ?options=value_id1,value_id2,value_id3

    // Get base menu item
    const { data: menuItem, error: itemError } = await supabase
      .from('menu_item')
      .select('*')
      .eq('menu_item_id', menuItemId)
      .single();

    if (itemError) throw itemError;

    // Get base nutrition
    const baseNutrition = await getNutritionForMenuItem(menuItemId);

    // Get base price
    const basePrice = await getBasePrice(menuItemId);

    // Initialize totals
    let totalPrice = parseFloat(basePrice) || 0;
    let totalCalories = baseNutrition?.calories || 0;
    let totalProtein = parseFloat(baseNutrition?.protein_grams) || 0;
    let totalFat = parseFloat(baseNutrition?.fat_grams) || 0;
    let totalCarbs = parseFloat(baseNutrition?.carbohydrates_grams) || 0;

    let configuredName = menuItem.display_name;
    const breakdown = [
      { name: `Base ${menuItem.display_name}`, price: parseFloat(basePrice) || 0 }
    ];

    const dietSets = [];
    const allergensPresentSet = new Set();
    const allergensPossibleSet = new Set();

    // Get base diets
    const baseDiets = await getPossibleDiets(menuItemId);
    if (baseDiets.length > 0) {
      dietSets.push(new Set(baseDiets));
    }

    // Process selected options
    if (options) {
      const valueIds = options.split(',').map(id => id.trim()).filter(Boolean);

      for (const valueId of valueIds) {
        // Get option value details
        const { data: optionValues, error: valError } = await supabase
          .from('option_value')
          .select('*')
          .eq('value_id', valueId)
          .limit(1);

        if (!valError && optionValues && optionValues.length > 0) {
          const optionValue = optionValues[0];
          configuredName += ` + ${optionValue.value_name}`;

          // Get nutrition for this option value
          const { data: optionNutritionData, error: nutError } = await supabase
            .from('option_value_nutrition')
            .select(`
              nutrition:nutrition_id (*)
            `)
            .eq('value_id', valueId)
            .limit(1);

          if (!nutError && optionNutritionData && optionNutritionData.length > 0) {
            const optionNutrition = optionNutritionData[0];
            if (optionNutrition?.nutrition) {
              totalCalories += optionNutrition.nutrition.calories || 0;
              totalProtein += parseFloat(optionNutrition.nutrition.protein_grams) || 0;
              totalFat += parseFloat(optionNutrition.nutrition.fat_grams) || 0;
              totalCarbs += parseFloat(optionNutrition.nutrition.carbohydrates_grams) || 0;
            }
          }

          // Get price for this option value
          const { data: optionPrices, error: priceError } = await supabase
            .from('item_price')
            .select('price_cents')
            .eq('value_id', valueId)
            .eq('is_active', true)
            .limit(1);

          const optionPriceValue = (optionPrices && optionPrices.length > 0) ? (optionPrices[0].price_cents / 100) : 0;
          totalPrice += optionPriceValue;

          breakdown.push({
            name: optionValue.value_name,
            price: parseFloat(optionPriceValue.toFixed(2))
          });

          // Get diets for this option value
          const { data: optionDiets, error: dietError } = await supabase
            .from('option_value_diet')
            .select(`
              diet:diet_id (
                diet_name
              )
            `)
            .eq('value_id', valueId);

          if (!dietError && optionDiets) {
            const dietNames = optionDiets.map(d => d.diet?.diet_name).filter(Boolean);
            if (dietNames.length > 0) {
              dietSets.push(new Set(dietNames));
            }
          }

          // Get allergens for this option value
          const { data: optionAllergens, error: allergError } = await supabase
            .from('option_value_allergen')
            .select(`
              allergen:allergen_id (
                name
              )
            `)
            .eq('value_id', valueId);

          if (!allergError && optionAllergens) {
            optionAllergens.forEach(a => {
              if (a.allergen?.name) {
                allergensPresentSet.add(a.allergen.name);
              }
            });
          }
        }
      }
    }

    // Calculate intersection of diets (item must satisfy ALL selected option diets)
    let compatibleDiets = [];
    if (dietSets.length > 0) {
      compatibleDiets = Array.from(dietSets[0]);
      for (let i = 1; i < dietSets.length; i++) {
        compatibleDiets = compatibleDiets.filter(diet => dietSets[i].has(diet));
      }
    }

    // Get possible allergens from ingredients
    const { data: ingredients, error: ingError } = await supabase
      .from('menu_item_ingredient')
      .select(`
        ingredient:ingredient_id (
          possible_allergens
        )
      `)
      .eq('menu_item_id', menuItemId);

    if (!ingError && ingredients) {
      ingredients.forEach(ing => {
        if (ing.ingredient?.possible_allergens) {
          const possibleAllergens = ing.ingredient.possible_allergens.split(',');
          possibleAllergens.forEach(a => allergensPossibleSet.add(a.trim()));
        }
      });
    }

    // Get best image
    const { data: bestImages, error: imgError } = await supabase
      .from('menu_item_image')
      .select(`
        image:image_id (
          image_url
        )
      `)
      .eq('menu_item_id', menuItemId)
      .order('quality_rating', { ascending: false })
      .order('display_order', { ascending: true })
      .limit(1);

    const bestImageUrl = (bestImages && bestImages.length > 0) ? bestImages[0].image?.image_url : null;

    res.json({
      data: {
        configured_item: configuredName,
        total_price: parseFloat(totalPrice.toFixed(2)),
        nutrition: {
          calories: Math.round(totalCalories),
          protein_grams: Math.round(totalProtein),
          fat_grams: Math.round(totalFat),
          carbs_grams: Math.round(totalCarbs)
        },
        diets: compatibleDiets,
        allergens_present: allergensPresentSet.size > 0 ? Array.from(allergensPresentSet) : ['none'],
        allergens_possible: Array.from(allergensPossibleSet),
        breakdown: breakdown,
        best_image: bestImageUrl
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// 3. GET /menu-items/:id/options/filter
// Filter customization options by diet, allergen restrictions, etc.
app.get('/api/menu-items/:id/options/filter', async (req, res) => {
  try {
    const menuItemId = req.params.id;
    const { diet, exclude_allergens, max_calories, min_protein } = req.query;

    // Get all customization options for this menu item
    const { data: customizations, error: custError } = await supabase
      .from('menu_item_customization')
      .select(`
        *,
        custom_option:option_id (
          option_id,
          name,
          option_type
        )
      `)
      .eq('menu_item_id', menuItemId)
      .order('display_order');

    if (custError) throw custError;

    const filteredOptions = [];

    for (const customization of customizations || []) {
      const optionId = customization.custom_option?.option_id;
      if (!optionId) continue;

      // Get option values for this customization
      const { data: optionValues, error: valError } = await supabase
        .from('option_value')
        .select('*')
        .eq('option_id', optionId)
        .eq('is_available', true);

      if (valError || !optionValues) continue;

      const filteredValues = [];

      for (const value of optionValues) {
        let passesFilter = true;

        // Filter by diet
        if (diet && passesFilter) {
          const { data: valueDiets, error: dietError } = await supabase
            .from('option_value_diet')
            .select(`
              diet:diet_id (
                diet_name
              )
            `)
            .eq('value_id', value.value_id);

          if (!dietError && valueDiets) {
            const dietNames = valueDiets.map(d => d.diet?.diet_name?.toLowerCase());
            passesFilter = dietNames.includes(diet.toLowerCase());
          } else {
            passesFilter = false;
          }
        }

        // Filter by allergen exclusions
        if (exclude_allergens && passesFilter) {
          const excludedAllergens = exclude_allergens.split(',').map(a => a.trim().toLowerCase());
          
          const { data: valueAllergens, error: allergError } = await supabase
            .from('option_value_allergen')
            .select(`
              allergen:allergen_id (
                name
              )
            `)
            .eq('value_id', value.value_id);

          if (!allergError && valueAllergens) {
            const allergenNames = valueAllergens.map(a => a.allergen?.name?.toLowerCase()).filter(Boolean);
            const hasExcludedAllergen = allergenNames.some(name => 
              excludedAllergens.some(excluded => name.includes(excluded))
            );
            passesFilter = !hasExcludedAllergen;
          }
        }

        // Filter by max calories
        if (max_calories && passesFilter) {
          const { data: nutritionData, error: nutError } = await supabase
            .from('option_value_nutrition')
            .select(`
              nutrition:nutrition_id (
                calories
              )
            `)
            .eq('value_id', value.value_id)
            .limit(1);

          if (!nutError && nutritionData && nutritionData.length > 0 && nutritionData[0].nutrition?.calories) {
            passesFilter = nutritionData[0].nutrition.calories <= parseInt(max_calories);
          }
        }

        // Filter by min protein
        if (min_protein && passesFilter) {
          const { data: nutritionData, error: nutError } = await supabase
            .from('option_value_nutrition')
            .select(`
              nutrition:nutrition_id (
                protein_grams
              )
            `)
            .eq('value_id', value.value_id)
            .limit(1);

          if (!nutError && nutritionData && nutritionData.length > 0 && nutritionData[0].nutrition?.protein_grams) {
            passesFilter = parseFloat(nutritionData[0].nutrition.protein_grams) >= parseFloat(min_protein);
          } else {
            passesFilter = false;
          }
        }

        if (passesFilter) {
          filteredValues.push(value);
        }
      }

      if (filteredValues.length > 0) {
        filteredOptions.push({
          option_id: customization.custom_option.option_id,
          name: customization.custom_option.name,
          is_required: customization.is_required,
          type: customization.custom_option.option_type,
          filtered_values: filteredValues
        });
      }
    }

    res.json({
      success: true,
      menu_item_id: parseInt(menuItemId),
      filters_applied: {
        diet: diet || null,
        exclude_allergens: exclude_allergens || null,
        max_calories: max_calories || null,
        min_protein: min_protein || null
      },
      options: filteredOptions
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// 4. GET /menu-items/search
// Advanced search for menu items with multiple filters
app.get('/api/menu-items/search', async (req, res) => {
  try {
    const { 
      query, 
      diet, 
      max_price, 
      min_protein, 
      max_calories,
      is_customizable,
      restaurant_id,
      restaurant_tags,
      limit = 50 
    } = req.query;

    let menuItemsQuery = supabase
      .from('menu_item')
      .select('*')
      .eq('is_active', true);

    // Text search
    if (query) {
      menuItemsQuery = menuItemsQuery.or(
        `display_name.ilike.%${query}%,item_description.ilike.%${query}%`
      );
    }

    // Customizable filter
    if (is_customizable !== undefined) {
      menuItemsQuery = menuItemsQuery.eq('is_customizable', is_customizable === 'true');
    }

    menuItemsQuery = menuItemsQuery.limit(parseInt(limit));

    const { data: menuItems, error: itemError } = await menuItemsQuery;

    if (itemError) throw itemError;

    // Apply additional filters
    const filteredItems = [];

    for (const item of menuItems || []) {
      let passesFilter = true;

      // Filter by restaurant
      if (restaurant_id && passesFilter) {
        const restaurant = await getRestaurantForMenuItem(item.menu_item_id);
        passesFilter = restaurant?.restaurant_id === parseInt(restaurant_id);
      }

      // Filter by restaurant tags
      if (restaurant_tags && passesFilter) {
        const restaurant = await getRestaurantForMenuItem(item.menu_item_id);
        if (restaurant?.restaurant_id) {
          const requestedTags = restaurant_tags.split(',').map(t => t.trim().toLowerCase());
          
          // Get tags for this restaurant
          const { data: restTags, error: tagError } = await supabase
            .from('restaurant_tag')
            .select(`
              tag:tag_id (
                tag_text
              )
            `)
            .eq('restaurant_id', restaurant.restaurant_id);

          if (!tagError && restTags && restTags.length > 0) {
            const restaurantTagTexts = restTags
              .map(rt => rt.tag?.tag_text?.toLowerCase())
              .filter(Boolean);
            // Check if restaurant has ANY of the requested tags
            passesFilter = requestedTags.some(reqTag => 
              restaurantTagTexts.some(restTag => restTag.includes(reqTag))
            );
          } else {
            passesFilter = false;
          }
        } else {
          passesFilter = false;
        }
      }

      // Filter by diet
      if (diet && passesFilter) {
        const diets = await getPossibleDiets(item.menu_item_id);
        passesFilter = diets.some(d => d.toLowerCase().includes(diet.toLowerCase()));
      }

      // Filter by max price
      if (max_price && passesFilter) {
        const price = await getBasePrice(item.menu_item_id);
        passesFilter = price && parseFloat(price) <= parseFloat(max_price);
      }

      // Filter by nutrition
      if ((min_protein || max_calories) && passesFilter) {
        const nutrition = await getNutritionForMenuItem(item.menu_item_id);
        
        if (nutrition) {
          if (min_protein) {
            passesFilter = passesFilter && parseFloat(nutrition.protein_grams) >= parseFloat(min_protein);
          }
          if (max_calories) {
            passesFilter = passesFilter && nutrition.calories <= parseInt(max_calories);
          }
        } else {
          passesFilter = false;
        }
      }

      if (passesFilter) {
        // Enrich item data
        const nutrition = await getNutritionForMenuItem(item.menu_item_id);
        const price = await getBasePrice(item.menu_item_id);
        const restaurant = await getRestaurantForMenuItem(item.menu_item_id);
        
        filteredItems.push({
          ...item,
          nutrition: nutrition,
          current_price: price ? parseFloat(price) : null,
          restaurant_name: restaurant?.name || null
        });
      }
    }

    res.json({
      success: true,
      count: filteredItems.length,
      filters_applied: {
        query: query || null,
        diet: diet || null,
        max_price: max_price || null,
        min_protein: min_protein || null,
        max_calories: max_calories || null,
        is_customizable: is_customizable || null,
        restaurant_id: restaurant_id || null,
        restaurant_tags: restaurant_tags || null
      },
      menu_items: filteredItems
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// 5. GET /menu-items/:id/options/lowest-calorie-vegan
// Implements endpoint #6 in add_endpoints.txt using the provided SQL logic
app.get('/api/menu-items/:id/options/lowest-calorie-vegan', async (req, res) => {
  try {
    const menuItemId = parseInt(req.params.id, 10);

    // Validate menu item ID
    if (isNaN(menuItemId)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid menu item ID'
      });
    }

    // Ensure the menu item exists and is active
    const { data: menuItem, error: menuItemError } = await supabase
      .from('menu_item')
      .select('menu_item_id, display_name, is_active')
      .eq('menu_item_id', menuItemId)
      .single();

    if (menuItemError || !menuItem) {
      return res.status(404).json({
        success: false,
        message: 'Menu item not found'
      });
    }

    if (!menuItem.is_active) {
      return res.status(400).json({
        success: false,
        message: 'Menu item is not active'
      });
    }

    // Fetch customization options so we can constrain option values to this menu item
    const { data: customizationLinks, error: custError } = await supabase
      .from('menu_item_customization')
      .select('option_id')
      .eq('menu_item_id', menuItemId);

    console.log('DEBUG: custError:', custError);
    console.log('DEBUG: customizationLinks raw:', JSON.stringify(customizationLinks, null, 2));
    if (custError) throw custError;
    const optionIds = customizationLinks?.map(c => c.option_id).filter(id => id !== null && id !== undefined) || [];
    console.log('DEBUG: optionIds for menu item', menuItemId, ':', optionIds);

    if (optionIds.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No customization options found for this menu item'
      });
    }

    // Fetch option values with left joins (allows missing nutrition/diet data)
    const { data: optionRows, error: optionsError } = await supabase
      .from('option_value')
      .select(`
        value_id,
        value_name,
        option_id,
        is_available,
        nutrition:option_value_nutrition(
          nutrition_id,
          nutrition:nutrition (
            calories
          )
        ),
        diet_link:option_value_diet(
          diet(diet_name)
        ),
        allergen_link:option_value_allergen(
          allergen(name)
        )
      `)
      .in('option_id', optionIds)
      .eq('is_available', true);

    if (optionsError) throw optionsError;
    console.log('DEBUG: optionRows count:', optionRows?.length || 0);
    console.log('DEBUG: optionRows:', JSON.stringify(optionRows, null, 2));

    // Filter for Vegan options (in-memory since we removed inner join)
    const veganOptions = (optionRows || []).filter(ov => {
      const diets = ov.diet_link || [];
      return diets.some(link => link.diet?.diet_name?.toLowerCase() === 'vegan');
    });
    console.log('DEBUG: veganOptions count:', veganOptions.length);

    // Apply the NOT EXISTS allergen filter (soy-free)
    const soyFreeOptions = veganOptions.filter(ov => {
      const hasSoy = (ov.allergen_link || []).some(link => link.allergen?.name?.toLowerCase() === 'soy');
      return !hasSoy;
    });
    console.log('DEBUG: soyFreeOptions count:', soyFreeOptions.length);

    // Sort by calories ascending (lowest first)
    // nutrition is now an array (many-to-many), get first entry's calories
    soyFreeOptions.sort((a, b) => {
      const calA = a.nutrition?.[0]?.nutrition?.calories ?? Infinity;
      const calB = b.nutrition?.[0]?.nutrition?.calories ?? Infinity;
      return calA - calB;
    });

    if (soyFreeOptions.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'No vegan, soy-free options found for this menu item'
      });
    }

    const bestOption = soyFreeOptions[0];
    // nutrition is now many-to-many (array), get first entry
    const nutritionData = bestOption.nutrition?.[0];

    res.json({
      success: true,
      data: {
        menu_item_id: menuItem.menu_item_id,
        menu_item_name: menuItem.display_name,
        value_id: bestOption.value_id,
        value_name: bestOption.value_name,
        nutrition_id: nutritionData?.nutrition_id || null,
        calories: nutritionData?.nutrition?.calories || null,
        diet_name: bestOption.diet_link?.[0]?.diet?.diet_name || 'Vegan'
      }
    });
  } catch (error) {
    console.error('Endpoint error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

// 6. GET /menu-items/:id/images
// Get all images for a menu item and selected option values
app.get('/api/menu-items/:id/images', async (req, res) => {
  try {
    const menuItemId = parseInt(req.params.id, 10);
    const { options } = req.query; // Expected format: ?options=value_id1,value_id2,value_id3

    // Validate menu item ID
    if (isNaN(menuItemId)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid menu item ID'
      });
    }

    // Ensure the menu item exists
    const { data: menuItem, error: menuItemError } = await supabase
      .from('menu_item')
      .select('menu_item_id, display_name, is_active')
      .eq('menu_item_id', menuItemId)
      .single();

    if (menuItemError || !menuItem) {
      return res.status(404).json({
        success: false,
        message: 'Menu item not found'
      });
    }

    // Get menu item images
    const { data: menuItemImages, error: menuImgError } = await supabase
      .from('menu_item_image')
      .select(`
        display_order,
        is_generated,
        is_verified,
        quality_rating,
        image:image_id (
          image_id,
          image_url,
          type,
          alt_text,
          is_generated,
          quality_rating
        )
      `)
      .eq('menu_item_id', menuItemId)
      .order('display_order', { ascending: true });

    if (menuImgError) {
      console.error('Error fetching menu item images:', menuImgError);
    }

    const formattedMenuItemImages = (menuItemImages || [])
      .filter(img => img.image)
      .map(img => ({
        image_id: img.image.image_id,
        image_url: img.image.image_url,
        type: img.image.type || 'food',
        alt_text: img.image.alt_text,
        is_generated: img.is_generated || img.image.is_generated || false,
        is_verified: img.is_verified || false,
        quality_rating: img.quality_rating || img.image.quality_rating,
        display_order: img.display_order,
        source: 'menu_item'
      }));

    // Get option value images if options are provided
    const optionValueImages = [];
    const optionValuesInfo = [];

    if (options) {
      const valueIds = options.split(',').map(id => parseInt(id.trim(), 10)).filter(id => !isNaN(id));

      for (const valueId of valueIds) {
        // Get option value details
        const { data: optionValue, error: ovError } = await supabase
          .from('option_value')
          .select('value_id, value_name, option_id')
          .eq('value_id', valueId)
          .single();

        if (ovError || !optionValue) {
          console.log(`Option value ${valueId} not found`);
          continue;
        }

        optionValuesInfo.push({
          value_id: optionValue.value_id,
          value_name: optionValue.value_name
        });

        // Get images for this option value
        const { data: ovImages, error: ovImgError } = await supabase
          .from('option_value_image')
          .select(`
            value_id,
            image:image_id (
              image_id,
              image_url,
              type,
              alt_text,
              is_generated,
              quality_rating
            )
          `)
          .eq('value_id', valueId);

        if (ovImgError) {
          console.error(`Error fetching images for option value ${valueId}:`, ovImgError);
          continue;
        }

        const formattedOvImages = (ovImages || [])
          .filter(img => img.image)
          .map(img => ({
            image_id: img.image.image_id,
            image_url: img.image.image_url,
            type: img.image.type || 'food',
            alt_text: img.image.alt_text,
            is_generated: img.image.is_generated || false,
            quality_rating: img.image.quality_rating,
            source: 'option_value',
            value_id: valueId,
            value_name: optionValue.value_name
          }));

        optionValueImages.push(...formattedOvImages);
      }
    }

    // Combine all images
    const allImages = [...formattedMenuItemImages, ...optionValueImages];

    // Deduplicate by image_id (in case same image is linked multiple times)
    const uniqueImages = [];
    const seenImageIds = new Set();
    for (const img of allImages) {
      if (!seenImageIds.has(img.image_id)) {
        seenImageIds.add(img.image_id);
        uniqueImages.push(img);
      }
    }

    res.json({
      success: true,
      data: {
        menu_item_id: menuItem.menu_item_id,
        menu_item_name: menuItem.display_name,
        option_values_requested: optionValuesInfo,
        images: {
          total_count: uniqueImages.length,
          menu_item_images: formattedMenuItemImages,
          option_value_images: optionValueImages,
          all_unique_images: uniqueImages
        },
        // Array of just URLs for easy consumption by image generators
        image_urls: uniqueImages.map(img => img.image_url).filter(Boolean)
      }
    });
  } catch (error) {
    console.error('Endpoint error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// DIAGNOSTIC ENDPOINT - Check data relationships for a menu item
app.get('/api/menu-items/:id/debug', async (req, res) => {
  try {
    const menuItemId = req.params.id;

    // Check if menu item exists
    const { data: menuItem, error: itemError } = await supabase
      .from('menu_item')
      .select('*')
      .eq('menu_item_id', menuItemId)
      .single();

    if (itemError) {
      return res.json({
        success: false,
        error: 'Menu item not found',
        menu_item_id: menuItemId
      });
    }

    // Check if menu exists (direct FK relationship in schema)
    let menus = [];
    let restaurants = [];
    const menuId = menuItem.menu_id;

    if (menuId) {
      const { data: menuData, error: menuError } = await supabase
        .from('menu')
        .select(`
          *,
          restaurant:restaurant_id (*)
        `)
        .eq('menu_id', menuId);
      
      menus = menuData || [];

      // Get restaurant directly from menu table (menu.restaurant_id FK)
      if (menuData && menuData.length > 0 && menuData[0].restaurant) {
        restaurants = [menuData[0].restaurant];
      }
    }

    // Check nutrition
    const { data: nutritionLinks, error: nutError } = await supabase
      .from('menu_item_nutrition')
      .select('nutrition_id')
      .eq('menu_item_id', menuItemId);

    // Check prices
    const { data: prices, error: priceError } = await supabase
      .from('item_price')
      .select('*')
      .eq('menu_item_id', menuItemId)
      .eq('is_active', true);

    // Check customizations
    const { data: customizations, error: custError } = await supabase
      .from('menu_item_customization')
      .select('*')
      .eq('menu_item_id', menuItemId);

    // Check diets
    const { data: diets, error: dietError } = await supabase
      .from('menu_item_diet')
      .select(`
        diet:diet_id (*)
      `)
      .eq('menu_item_id', menuItemId);

    // Check images
    const { data: images, error: imgError } = await supabase
      .from('menu_item_image')
      .select('*')
      .eq('menu_item_id', menuItemId);

    res.json({
      success: true,
      menu_item_id: menuItemId,
      menu_item: menuItem,
      relationships: {
        menu: {
          menu_id: menuId || null,
          has_menu: !!menuId,
          menus: menus
        },
        restaurants: {
          count: restaurants.length,
          restaurants: restaurants
        },
        nutrition: {
          count: nutritionLinks?.length || 0,
          nutrition_ids: nutritionLinks?.map(n => n.nutrition_id) || [],
          error: nutError?.message || null
        },
        prices: {
          count: prices?.length || 0,
          prices: prices || [],
          error: priceError?.message || null
        },
        customizations: {
          count: customizations?.length || 0,
          error: custError?.message || null
        },
        diets: {
          count: diets?.length || 0,
          diets: diets || [],
          error: dietError?.message || null
        },
        images: {
          count: images?.length || 0,
          error: imgError?.message || null
        }
      },
      recommendations: generateRecommendations(menuId, menus, restaurants, prices, nutritionLinks)
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// Helper to generate recommendations for missing data
function generateRecommendations(menuId, menus, restaurants, prices, nutritionLinks) {
  const recommendations = [];

  if (!menuId) {
    recommendations.push('‚ùå No menu_id found on menu_item. Need to set menu_item.menu_id FK.');
  }

  if (menus.length === 0) {
    recommendations.push('‚ùå No menu found. Need to create menu record and set menu_item.menu_id.');
  }

  if (restaurants.length === 0) {
    recommendations.push('‚ùå No restaurants found. Need to create restaurant record and set menu.restaurant_id FK.');
  }

  if (!prices || prices.length === 0) {
    recommendations.push('‚ö†Ô∏è  No prices found in item_price table.');
  }

  if (!nutritionLinks || nutritionLinks.length === 0) {
    recommendations.push('‚ö†Ô∏è  No nutrition data found. Need to insert into menu_item_nutrition table.');
  }

  if (recommendations.length === 0) {
    recommendations.push('‚úÖ All critical relationships exist!');
  }

  return recommendations;
}

// Start server
app.listen(PORT, () => {
  console.log(`üçΩÔ∏è  Menu Items API v3 running on http://localhost:${PORT}`);
  console.log(`\nüìã Schema Version: 11_24`);
  console.log(`   - Direct menu_item.menu_id FK`);
  console.log(`   - Direct menu.restaurant_id FK (no restaurant_menu junction)`);
  console.log(`\nüÜï Enhanced Endpoints:`);
  console.log(`  GET  /                                               - Test server status`);
  console.log(`  GET  /api/menu-items/:id                             - Get menu item with full details`);
  console.log(`  GET  /api/menu-items/:id/configure                   - Configure menu item with options`);
  console.log(`                                                          Query: ?options=value_id1,value_id2`);
  console.log(`  GET  /api/menu-items/:id/options/filter              - Filter options by diet/allergens/nutrition`);
  console.log(`                                                          Query: ?diet=vegan&exclude_allergens=soy,dairy`);
  console.log(`                                                                 &max_calories=500&min_protein=20`);
  console.log(`  GET  /api/menu-items/:id/options/lowest-calorie-vegan - Find lowest calorie vegan & soy-free option`);
  console.log(`                                                          Query: ?debug=true for detailed info`);
  console.log(`  GET  /api/menu-items/:id/images                      - Get all images for menu item + option values`);
  console.log(`                                                          Query: ?options=value_id1,value_id2`);
  console.log(`  GET  /api/menu-items/search                          - Advanced search with multiple filters`);
  console.log(`                                                          Query: ?query=bowl&diet=vegan&max_price=15`);
  console.log(`                                                                 &min_protein=20&is_customizable=true`);
  console.log(`                                                                 &restaurant_tags=mexican,fast-casual`);
  console.log(`\nüîç Diagnostic Endpoint:`);
  console.log(`  GET  /api/menu-items/:id/debug                       - Check all data relationships for menu item\n`);
});